# 数组和元组类型

## 数组

数组类型的标注有两种方式：

```ts
const arr1: string[] = ['1', '2', '3']

const arr2: Array<string> = ['4', '5', '6']
```

这两种方式其实是等价的，将鼠标移入到 `arr2` 上，会发现它显示的类型签名是 `string[]`。上面的数组类型标注，只能表示数组各项的类型是唯一的，如果想要标注数组各项类型是多种可能的，需要用到**联合类型**，如下：

```ts
const arr3: (string | number | boolean)[] = [false, 4]
const arr4: Array<string | number | boolean> = ['1', 3]
```

使用联合类型 `string | number | boolean` 标注后，数组各项值可以是这三种数据类型中的任意一种。关于联合类型，后面会具体说到，这里只做了解。

## 元组

接下来说元组类型。元组是 ts 中新增的类型，它本质也是数组，但是一个**已知元素数量和元素类型的数组**。也就是说元组定义后，它的元素数量和类型就固定死了，且元素顺序要和类型顺序一致，直接看代码：

```ts
// 定义了元组有三个元素，且每个元素的类型都标注了，此时数组各项值的类型都要按照类型顺序填入
const arr5: [string, number, boolean] = ['5', 6, false]

// ❌，第一项值和第二项值没有按照类型标注顺序填入
const arr6: [string, number, boolean] = [5, '6', true]

// ❌，没有标注第四项类型，却填入了第四项值
const arr7: [string, number, boolean] = ['5', 6, false, 'hi']
```

由上可见，元组相比数组一个优势就是固定结构。一旦定义，结构就不会改变，任何超出结构的行为都会报错，这对于需要确保数据结构稳定性的场景非常有用，比如在函数中返回元组类型，就可以清晰地表明每个值的意义。

元组另一个优势就是可以避免越界访问。当我们使用数组类型时，我们可以任意访问它的某一个元素，即使这个元素是不存在的，如：

```ts
const arr8: string[] = ['1', '2', '3']
// 这里可以访问超出定义数组长度之外的元素
console.log(arr8[100])
```

这种情况不应符合预期，因为确定数组中只有三个成员，当越界访问时，应该给出类型报错。这时候就可以使用元组来定义：

```ts
const arr9: [string, string, string] = ['1', '2', '3']

// ❌，Tuple type '[string, string, string]' of length '3' has no element at index '100'
arr9[100]
```

越界访问本身就没有任何意义，所以使用元组来规避这种错误是很好的方式。

另外元组也支持了某一项元素是可选的：

```ts
// 第二项和第三项都是可选的，可以不填入元素
const arr10: [string, number?, boolean?] = ['hi']
```

注意，对于上面被标记为可选的元素，在开启 `strictNullCheckes` 配置后，会分别被视为一个 `number | undefined`类型和 `boolean | undefined` 类型。

有可选成员的元组的长度也会发生变化，如上元组 arr10，其长度为 `1 | 2 | 3`，也就是长度可能是 1，可能是 2，也可能是 3，这不难理解，因为有 2 个是可选的元素成员。

看到这里，不知道你有没有觉得元组的类型标注跟对象类似，或者说不如用对象，比如对于 `[string，number，boolean]` 来说，我们不能直接知道这三个元素都代表啥，还不如使用对象的形式。好的，于是在 TypeScript 4.0 版本中，加入了具名元组的功能支持，我们可以为元组中的元素都打上类似属性的标记，如下：

```ts
const arr11: [name: string, age?: number, male?: boolean] = ['pz']
```

是不是很酷！在一些简单的场景，完全可以使用具名元组来替换对象。

## 总结

本节主要介绍了数组和元组的类型标注方式以及区别。元组本质上也是数组，只是固定了成员数量和类型，可以避免越界访问成员所产生的不可预期的错误。
